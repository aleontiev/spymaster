{% extends "base.html" %}

{% block title %}Data Browser - Spymaster{% endblock %}

{% block content %}
<div x-data="dataBrowser()" x-init="init(); window.dataBrowserInstance = $data">
    <!-- Page Header with Tabs -->
    <div class="flex items-center justify-between mb-6">
        <h1 class="text-3xl font-bold">Data</h1>
        <div class="flex bg-neutral-800 rounded-lg p-1">
            <button @click="activeTab = 'browse'"
                    :class="activeTab === 'browse' ? 'bg-primary-600 text-white' : 'text-gray-400 hover:text-white'"
                    class="px-4 py-2 rounded-md text-sm font-medium transition-colors flex items-center gap-2">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                </svg>
                Browse
            </button>
            <button @click="activeTab = 'files'"
                    :class="activeTab === 'files' ? 'bg-primary-600 text-white' : 'text-gray-400 hover:text-white'"
                    class="px-4 py-2 rounded-md text-sm font-medium transition-colors flex items-center gap-2">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                </svg>
                Files
            </button>
            <button @click="activeTab = 'pipeline'; loadPipelineData()"
                    :class="activeTab === 'pipeline' ? 'bg-primary-600 text-white' : 'text-gray-400 hover:text-white'"
                    class="px-4 py-2 rounded-md text-sm font-medium transition-colors flex items-center gap-2">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 17V7m0 10a2 2 0 01-2 2H5a2 2 0 01-2-2V7a2 2 0 012-2h2a2 2 0 012 2m0 10a2 2 0 002 2h2a2 2 0 002-2M9 7a2 2 0 012-2h2a2 2 0 012 2m0 10V7m0 10a2 2 0 002 2h2a2 2 0 002-2V7a2 2 0 00-2-2h-2a2 2 0 00-2 2"></path>
                </svg>
                Pipeline
            </button>
        </div>
    </div>

    {% include 'data/_browse.html' %}
    {% include 'data/_files.html' %}
    {% include 'data/_pipeline.html' %}
    {% include 'data/_chart_modal.html' %}
</div>
{% endblock %}

{% block styles %}
<style>
/* Pipeline DAG Styles */
#pipeline-dag .node rect {
    transition: all 0.2s ease;
    cursor: pointer;
}

#pipeline-dag .node:hover rect {
    filter: brightness(1.2);
    transform: translateY(-2px);
}

#pipeline-dag .connections path {
    transition: stroke-opacity 0.2s ease;
}

#pipeline-dag:hover .connections path {
    stroke-opacity: 0.8;
}
</style>
{% endblock %}

{% block scripts %}
<script>
function dataBrowser() {
    return {
        activeTab: 'browse',
        tree: null,
        summary: null,
        currentPath: '',
        selectedFile: null,
        selectedPath: '',
        previewData: null,
        previewTab: 'data',
        previewOffset: 0,
        previewLimit: 200,
        statsData: null,
        fileInfo: null,
        sortColumn: null,
        sortDirection: 'asc',
        loadingMore: false,
        allData: [],
        expandedFolders: {},
        selectedColumn: null,
        histogramData: null,
        histogramLoading: false,
        folderScrollState: {},
        ITEM_HEIGHT: 28,
        VISIBLE_BUFFER: 20,
        selectedPytorchKey: null,
        pytorchKeyData: null,
        pytorchKeyLoading: false,
        miniChartData: null,
        miniChartLoading: false,
        miniChartError: null,
        miniCharts: {},
        chartModalOpen: false,
        chartData: null,
        chartLoading: false,
        chartError: null,
        chartZoomed: false,
        showZoomButton: true,
        charts: {},
        chartSeries: {},
        overlayVisible: {
            vwap: false,  // Cumulative VWAP hidden by default
            rollingVwap: false,  // Rolling VWAP hidden by default
            vwapUpper1: false,  // VWAP +1 std band
            vwapLower1: false,  // VWAP -1 std band
            vwapUpper2: false,  // VWAP +2 std band
            vwapLower2: false,  // VWAP -2 std band
            // Zero crossing levels
            zeroGex: false,  // Hidden by default
            zeroDex: false,  // Hidden by default
            // Weighted centroids (GWS/DWS)
            positiveGws: false,  // GWS hidden by default (use Volume category instead)
            negativeGws: false,
            deltaSupport: false,  // Delta support/resistance hidden by default
            deltaResistance: false,
            // Wall levels (max exposure strikes)
            gammaCallWall: false,  // Walls hidden by default (more volatile)
            gammaPutWall: false,
            dexCallWall: false,
            dexPutWall: false,
            // Volume levels (volume-weighted strikes)
            mostActiveStrike: true,
            callWeightedStrike: true,  // +WS
            putWeightedStrike: true,   // -WS
            maxCallStrike: false,      // MCS - hidden by default
            maxPutStrike: false,       // MPS - hidden by default
            pointOfControl: false,     // POC - strike with highest total volume
            // High/Low levels (historical context - hidden by default)
            premarketHigh: false,
            premarketLow: false,
            threeDayHigh: false,
            threeDayLow: false,
        },

        // Pipeline node selection state
        selectedPipelineNode: null,
        nodeDetailTab: 'metadata',
        nodeDataStats: { loading: false, data: null },

        // Browse tab state
        browseDataset: '',
        browseUnderlying: '',
        browseDatePreset: 'last30',
        browseDateStart: '',
        browseDateEnd: '',
        browseCalendar: { loading: false, months: [], stats: null },
        browseSelectedDate: null,
        browseSelectedFile: null,
        browseCurrentMonth: new Date().getMonth(),  // 0-indexed (0 = January)
        browseCurrentYear: new Date().getFullYear(),

        // Internal state
        _initializing: false,

        // Pipeline data loaded from database
        pipelineNodes: {},
        pipelineEdges: [],
        pipelineSummary: { source_count: 0, computed_count: 0, total_fields: 0 },
        pipelineLoading: false,
        pipelineError: null,
        datasetsLoaded: false,

        // Underlyings loaded from data folder
        availableUnderlyings: [],
        underlyingsLoaded: false,

        // Load pipeline data from API
        async loadPipelineData() {
            if (this.pipelineLoading) return;
            this.pipelineLoading = true;
            this.pipelineError = null;

            try {
                const res = await fetch('/api/pipeline');
                const data = await res.json();

                if (data.error) {
                    this.pipelineError = data.error;
                    return;
                }

                // Convert nodes array to object keyed by name
                this.pipelineNodes = {};
                for (const node of data.nodes) {
                    this.pipelineNodes[node.name] = node;
                }
                this.pipelineEdges = data.edges;
                this.pipelineSummary = data.summary;
                this.datasetsLoaded = true;

            } catch (e) {
                this.pipelineError = e.message;
            } finally {
                this.pipelineLoading = false;
            }
        },

        // Get nodes by type
        getNodesByType(type) {
            return Object.values(this.pipelineNodes).filter(n => n.type === type);
        },

        // Get datasets grouped by type for dropdown
        getDatasetsByGroup() {
            const sources = Object.values(this.pipelineNodes)
                .filter(n => n.type === 'source')
                .map(n => n.name)
                .sort();
            const computed = Object.values(this.pipelineNodes)
                .filter(n => n.type === 'computed' && !n.name.includes('normalized'))
                .map(n => n.name)
                .sort();
            const training = Object.values(this.pipelineNodes)
                .filter(n => n.name.includes('normalized'))
                .map(n => n.name)
                .sort();
            return { sources, computed, training };
        },

        // Update dataset select options dynamically
        updateDatasetOptions(select) {
            if (!select || !this.datasetsLoaded) return;

            const currentValue = this.browseDataset;
            const groups = this.getDatasetsByGroup();

            // Clear existing options
            select.innerHTML = '';

            // Add Sources group
            if (groups.sources.length > 0) {
                const sourcesGroup = document.createElement('optgroup');
                sourcesGroup.label = 'Sources';
                groups.sources.forEach(ds => {
                    const opt = document.createElement('option');
                    opt.value = ds;
                    opt.textContent = ds;
                    if (ds === currentValue) opt.selected = true;
                    sourcesGroup.appendChild(opt);
                });
                select.appendChild(sourcesGroup);
            }

            // Add Computed group
            if (groups.computed.length > 0) {
                const computedGroup = document.createElement('optgroup');
                computedGroup.label = 'Computed';
                groups.computed.forEach(ds => {
                    const opt = document.createElement('option');
                    opt.value = ds;
                    opt.textContent = ds;
                    if (ds === currentValue) opt.selected = true;
                    computedGroup.appendChild(opt);
                });
                select.appendChild(computedGroup);
            }

            // Add Training group
            if (groups.training.length > 0) {
                const trainingGroup = document.createElement('optgroup');
                trainingGroup.label = 'Training';
                groups.training.forEach(ds => {
                    const opt = document.createElement('option');
                    opt.value = ds;
                    opt.textContent = ds;
                    if (ds === currentValue) opt.selected = true;
                    trainingGroup.appendChild(opt);
                });
                select.appendChild(trainingGroup);
            }

            // Ensure model is in sync
            if (select.value !== currentValue) {
                select.value = currentValue;
            }
        },

        // Load available underlyings from API
        async loadUnderlyings() {
            try {
                const res = await fetch('/api/dataset/underlyings');
                const data = await res.json();
                if (data.underlyings) {
                    this.availableUnderlyings = data.underlyings;
                    this.underlyingsLoaded = true;

                    // Set default underlying if not already set
                    if (!this.browseUnderlying && this.availableUnderlyings.length > 0) {
                        this.browseUnderlying = this.availableUnderlyings[0]; // SPY is first
                    }
                }
            } catch (e) {
                console.error('Error loading underlyings:', e);
            }
        },

        // Update underlying select options dynamically
        updateUnderlyingOptions(select) {
            if (!select || !this.underlyingsLoaded) return;

            const currentValue = this.browseUnderlying;

            // Clear existing options
            select.innerHTML = '';

            // Add options for each underlying
            this.availableUnderlyings.forEach(underlying => {
                const opt = document.createElement('option');
                opt.value = underlying;
                opt.textContent = underlying;
                if (underlying === currentValue) opt.selected = true;
                select.appendChild(opt);
            });

            // Ensure model is in sync
            if (select.value !== currentValue && this.availableUnderlyings.includes(currentValue)) {
                select.value = currentValue;
            } else if (!currentValue && this.availableUnderlyings.length > 0) {
                // If no current value, select the first option
                this.browseUnderlying = this.availableUnderlyings[0];
                select.value = this.availableUnderlyings[0];
            }
        },

        // Pipeline node selection
        selectPipelineNode(nodeId) {
            if (this.selectedPipelineNode === nodeId) {
                this.selectedPipelineNode = null;
            } else {
                this.selectedPipelineNode = nodeId;
                this.nodeDetailTab = 'metadata';
                this.nodeDataStats = { loading: false, data: null };
            }
            this.updateUrl();
        },

        getPipelineNodeInfo(nodeId) {
            return this.pipelineNodes[nodeId] || null;
        },

        isNodeVisible(nodeId) {
            if (!this.selectedPipelineNode) return true;
            if (nodeId === this.selectedPipelineNode) return true;
            const selected = this.pipelineNodes[this.selectedPipelineNode];
            if (!selected) return true;
            if (selected.dependencies?.includes(nodeId)) return true;
            if (selected.dependents?.includes(nodeId)) return true;
            return false;
        },

        edgeExists(fromNode, toNode) {
            // Check if this edge exists in the database-loaded pipelineEdges
            return this.pipelineEdges.some(e => e.from === fromNode && e.to === toNode);
        },

        isConnectionVisible(fromNode, toNode) {
            // First check if this edge actually exists in the database
            if (!this.edgeExists(fromNode, toNode)) return false;

            // Then apply selection-based visibility
            if (!this.selectedPipelineNode) return true;
            if (fromNode === this.selectedPipelineNode || toNode === this.selectedPipelineNode) {
                return true;
            }
            return false;
        },

        async loadNodeDataStats() {
            if (!this.selectedPipelineNode) return;
            this.nodeDataStats = { loading: true, data: null };
            try {
                const res = await fetch(`/api/dataset/stats?dataset=${encodeURIComponent(this.selectedPipelineNode)}&underlying=SPY`);
                const data = await res.json();
                this.nodeDataStats = { loading: false, data };
            } catch (e) {
                console.error('Failed to load node stats:', e);
                this.nodeDataStats = { loading: false, data: null };
            }
        },

        // Browse tab functions
        applyDatePreset() {
            const now = new Date();
            const today = now.toISOString().split('T')[0];

            switch (this.browseDatePreset) {
                case 'last30':
                    this.browseDateEnd = today;
                    this.browseDateStart = new Date(now.setDate(now.getDate() - 30)).toISOString().split('T')[0];
                    break;
                case 'last90':
                    this.browseDateEnd = today;
                    this.browseDateStart = new Date(now.setDate(now.getDate() - 90)).toISOString().split('T')[0];
                    break;
                case 'thisYear':
                    this.browseDateEnd = today;
                    this.browseDateStart = `${new Date().getFullYear()}-01-01`;
                    break;
                case 'lastYear':
                    const lastYear = new Date().getFullYear() - 1;
                    this.browseDateStart = `${lastYear}-01-01`;
                    this.browseDateEnd = `${lastYear}-12-31`;
                    break;
                case 'last5Years':
                    this.browseDateEnd = today;
                    this.browseDateStart = `${new Date().getFullYear() - 5}-01-01`;
                    break;
                case 'all':
                    this.browseDateStart = '2020-01-01';
                    this.browseDateEnd = today;
                    break;
                case 'custom':
                    // Don't auto-load for custom
                    return;
            }
            this.loadBrowseCalendar();
        },

        async loadBrowseCalendar() {
            this.browseCalendar = { loading: true, months: [], stats: null };
            this.browseSelectedDate = null;
            this.browseSelectedFile = null;

            try {
                const params = new URLSearchParams({
                    dataset: this.browseDataset,
                    underlying: this.browseUnderlying,
                    start_date: this.browseDateStart,
                    end_date: this.browseDateEnd,
                });
                const res = await fetch(`/api/dataset/calendar?${params}`);
                const data = await res.json();
                this.browseCalendar = { loading: false, months: data.months || [], stats: data.stats };

                // Navigate to the most recent month with data
                if (data.months?.length > 0) {
                    const lastMonth = data.months[data.months.length - 1];
                    const [year, month] = lastMonth.key.split('-');
                    this.browseCurrentYear = parseInt(year);
                    this.browseCurrentMonth = parseInt(month) - 1;
                }
            } catch (e) {
                console.error('Failed to load calendar:', e);
                this.browseCalendar = { loading: false, months: [], stats: null };
            }
        },

        async openBrowseDate(dateStr) {
            // Immediately fetch file info and open in Files tab
            this.browseSelectedDate = dateStr;
            try {
                const params = new URLSearchParams({
                    dataset: this.browseDataset,
                    underlying: this.browseUnderlying,
                    date: dateStr,
                });
                const res = await fetch(`/api/dataset/file?${params}`);
                const fileInfo = await res.json();
                if (fileInfo?.path) {
                    // Switch to Files tab first
                    this.activeTab = 'files';
                    // Wait for DOM to update after tab switch, then expand folders
                    this.$nextTick(() => {
                        // Collapse all folders and expand only the path to this file
                        this.expandPathHierarchy(fileInfo.path);
                        this.selectFile({
                            name: fileInfo.name,
                            path: fileInfo.path,
                            size: fileInfo.size
                        });
                    });
                }
            } catch (e) {
                console.error('Failed to load file info:', e);
            }
        },

        // Month navigation functions
        getCurrentMonthData() {
            if (!this.browseCalendar.months?.length) return null;
            const key = `${this.browseCurrentYear}-${String(this.browseCurrentMonth + 1).padStart(2, '0')}`;
            return this.browseCalendar.months.find(m => m.key === key);
        },

        getCurrentMonthLabel() {
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                              'July', 'August', 'September', 'October', 'November', 'December'];
            return `${monthNames[this.browseCurrentMonth]} ${this.browseCurrentYear}`;
        },

        prevMonth() {
            if (this.browseCurrentMonth === 0) {
                this.browseCurrentMonth = 11;
                this.browseCurrentYear--;
            } else {
                this.browseCurrentMonth--;
            }
            this.updateUrl();
        },

        nextMonth() {
            if (this.browseCurrentMonth === 11) {
                this.browseCurrentMonth = 0;
                this.browseCurrentYear++;
            } else {
                this.browseCurrentMonth++;
            }
            this.updateUrl();
        },

        hasDataInMonth(year, month) {
            const key = `${year}-${String(month + 1).padStart(2, '0')}`;
            return this.browseCalendar.months?.some(m => m.key === key);
        },

        getMonthsWithData() {
            return this.browseCalendar.months?.map(m => m.key) || [];
        },

        goToMonthWithData(direction) {
            // Find next/prev month that has data
            const months = this.getMonthsWithData();
            if (!months.length) return;

            const currentKey = `${this.browseCurrentYear}-${String(this.browseCurrentMonth + 1).padStart(2, '0')}`;
            const currentIndex = months.indexOf(currentKey);

            if (direction === 'prev') {
                if (currentIndex > 0) {
                    const [year, month] = months[currentIndex - 1].split('-');
                    this.browseCurrentYear = parseInt(year);
                    this.browseCurrentMonth = parseInt(month) - 1;
                } else if (currentIndex === -1) {
                    // Find closest month before current
                    for (let i = months.length - 1; i >= 0; i--) {
                        if (months[i] < currentKey) {
                            const [year, month] = months[i].split('-');
                            this.browseCurrentYear = parseInt(year);
                            this.browseCurrentMonth = parseInt(month) - 1;
                            break;
                        }
                    }
                }
            } else {
                if (currentIndex !== -1 && currentIndex < months.length - 1) {
                    const [year, month] = months[currentIndex + 1].split('-');
                    this.browseCurrentYear = parseInt(year);
                    this.browseCurrentMonth = parseInt(month) - 1;
                } else if (currentIndex === -1) {
                    // Find closest month after current
                    for (let i = 0; i < months.length; i++) {
                        if (months[i] > currentKey) {
                            const [year, month] = months[i].split('-');
                            this.browseCurrentYear = parseInt(year);
                            this.browseCurrentMonth = parseInt(month) - 1;
                            break;
                        }
                    }
                }
            }
            this.updateUrl();
        },

        viewBrowseFile() {
            if (!this.browseSelectedFile?.path) return;
            this.activeTab = 'files';
            // Collapse all folders and expand only the path to this file
            this.expandPathHierarchy(this.browseSelectedFile.path);
            this.selectFile({
                name: this.browseSelectedFile.name,
                path: this.browseSelectedFile.path,
                size: this.browseSelectedFile.size
            });
        },

        async init() {
            console.log('dataBrowser init() starting...');
            try {
                // Flag to prevent URL updates during initialization
                this._initializing = true;

                // Load tree, summary, pipeline, and underlyings data in parallel
                const [treeRes, summaryRes, pipelineRes, underlyingsRes] = await Promise.all([
                    fetch('/api/data'),
                    fetch('/api/data/summary'),
                    fetch('/api/pipeline'),
                    fetch('/api/dataset/underlyings')
                ]);
                this.tree = await treeRes.json();
                this.summary = await summaryRes.json();

                // Load pipeline data for datasets dropdown
                const pipelineData = await pipelineRes.json();
                if (!pipelineData.error) {
                    this.pipelineNodes = {};
                    for (const node of pipelineData.nodes) {
                        this.pipelineNodes[node.name] = node;
                    }
                    this.pipelineEdges = pipelineData.edges;
                    this.pipelineSummary = pipelineData.summary;
                    this.datasetsLoaded = true;

                    // Set default dataset if not already set (from URL)
                    if (!this.browseDataset) {
                        const groups = this.getDatasetsByGroup();
                        if (groups.sources.length > 0) {
                            this.browseDataset = groups.sources[0];
                        }
                    }
                }

                // Load underlyings
                const underlyingsData = await underlyingsRes.json();
                if (underlyingsData.underlyings) {
                    this.availableUnderlyings = underlyingsData.underlyings;
                    this.underlyingsLoaded = true;

                    // Set default underlying if not already set (from URL)
                    if (!this.browseUnderlying && this.availableUnderlyings.length > 0) {
                        this.browseUnderlying = this.availableUnderlyings[0]; // SPY is first
                    }
                }

                // Restore state from URL
                this.restoreStateFromUrl();

                // Listen for back/forward navigation
                window.addEventListener('popstate', () => {
                    this._initializing = true;
                    this.restoreStateFromUrl(true);
                    this._initializing = false;
                });

                // Watch for tab changes and update URL (skip during init)
                this.$watch('activeTab', (newTab) => {
                    if (!this._initializing) {
                        this.updateUrl();
                    }
                });

                // Done initializing
                this._initializing = false;
                console.log('dataBrowser init() complete, activeTab=', this.activeTab);
            } catch (e) {
                console.error('Error initializing data browser:', e);
                this._initializing = false;
            }
        },

        // URL State Management
        buildUrl() {
            if (!this.activeTab) return '/data/browse';

            const params = new URLSearchParams();

            if (this.activeTab === 'browse') {
                if (this.browseDataset) params.set('dataset', this.browseDataset);
                if (this.browseUnderlying) params.set('underlying', this.browseUnderlying);
                if (this.browseDatePreset) params.set('range', this.browseDatePreset);
                if (this.browseDatePreset === 'custom') {
                    if (this.browseDateStart) params.set('start', this.browseDateStart);
                    if (this.browseDateEnd) params.set('end', this.browseDateEnd);
                }
                // Include current month view
                if (this.browseCurrentYear && this.browseCurrentMonth !== undefined) {
                    params.set('month', `${this.browseCurrentYear}-${String(this.browseCurrentMonth + 1).padStart(2, '0')}`);
                }
            } else if (this.activeTab === 'files' && this.selectedPath) {
                params.set('file', this.selectedPath);
                // Add extended parameter when chart modal is open
                if (this.chartModalOpen) {
                    params.set('extended', '1');
                }
            } else if (this.activeTab === 'pipeline' && this.selectedPipelineNode) {
                params.set('node', this.selectedPipelineNode);
            }

            const queryString = params.toString();
            return `/data/${this.activeTab}${queryString ? '?' + queryString : ''}`;
        },

        updateUrl(replace = false) {
            const url = this.buildUrl();
            if (replace) {
                history.replaceState({ tab: this.activeTab }, '', url);
            } else {
                history.pushState({ tab: this.activeTab }, '', url);
            }
        },

        restoreStateFromUrl(fromPopstate = false) {
            const path = window.location.pathname;
            const params = new URLSearchParams(window.location.search);

            console.log('restoreStateFromUrl: path=', path, 'fromPopstate=', fromPopstate);

            // Parse tab from path: /data/browse, /data/files, /data/pipeline
            const pathMatch = path.match(/\/data\/(\w+)/);
            if (pathMatch) {
                const tab = pathMatch[1];
                console.log('restoreStateFromUrl: matched tab=', tab);
                if (['browse', 'files', 'pipeline'].includes(tab)) {
                    this.activeTab = tab;
                    console.log('restoreStateFromUrl: set activeTab to', tab);
                }
            } else if (path === '/data' || path === '/data/') {
                this.activeTab = 'browse';
                console.log('restoreStateFromUrl: defaulting to browse');
            }

            // Restore browse tab state
            if (this.activeTab === 'browse') {
                if (params.has('dataset')) this.browseDataset = params.get('dataset');
                if (params.has('underlying')) this.browseUnderlying = params.get('underlying');
                if (params.has('range')) this.browseDatePreset = params.get('range');
                if (params.has('start')) this.browseDateStart = params.get('start');
                if (params.has('end')) this.browseDateEnd = params.get('end');
                if (params.has('month')) {
                    const [year, month] = params.get('month').split('-');
                    this.browseCurrentYear = parseInt(year);
                    this.browseCurrentMonth = parseInt(month) - 1;
                }
                // Load calendar data
                this.applyDatePreset();
            } else {
                // Initialize browse dates for when user switches to browse tab
                this.applyDatePreset();
            }

            // Restore files tab state
            if (this.activeTab === 'files' && params.has('file')) {
                const filePath = params.get('file');
                const shouldOpenChart = params.has('extended');
                // Expand folder hierarchy and select file after tree loads
                this.$nextTick(() => {
                    this.expandPathHierarchy(filePath);
                    const fileName = filePath.split('/').pop();
                    this.selectFile({ name: fileName, path: filePath, size: 0 });
                    // Auto-open chart if extended parameter is present
                    if (shouldOpenChart) {
                        this.$nextTick(() => this.openChart());
                    }
                });
            }

            // Restore pipeline tab state
            if (this.activeTab === 'pipeline') {
                this.loadPipelineData();
                if (params.has('node')) {
                    this.selectedPipelineNode = params.get('node');
                }
            }

            // Replace the current URL to normalize it
            if (!fromPopstate) {
                this.updateUrl(true);
            }
        },

        // Update URL when browse controls change
        onBrowseControlChange() {
            this.loadBrowseCalendar();
            this.updateUrl();
        },

        // Update URL when month changes
        onMonthChange() {
            this.updateUrl();
        },

        get sortedData() {
            return this.allData;
        },

        async sortByColumn(colName) {
            if (this.sortColumn === colName) {
                this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                this.sortColumn = colName;
                this.sortDirection = 'asc';
            }
            this.allData = [];
            this.previewOffset = 0;
            this.loadingMore = false;
            await this.loadPreview();
        },

        toggleFolder(path) {
            this.expandedFolders[path] = !this.expandedFolders[path];
            const treeContainer = document.querySelector('[x-html="renderTree(tree)"]');
            if (treeContainer) {
                treeContainer.innerHTML = this.renderTree(this.tree);
            }
        },

        expandPathHierarchy(filePath) {
            // Collapse all folders first, then expand only the path to the selected file
            // This provides a clean view showing the hierarchy leading to the file
            // e.g., "data/stocks-1m/SPY/2024-12/16.parquet" expands:
            //   "data", "data/stocks-1m", "data/stocks-1m/SPY", "data/stocks-1m/SPY/2024-12"

            // Reset all expanded folders
            this.expandedFolders = {};

            // Expand only the folders in the path to this file
            const parts = filePath.split('/');
            let currentPath = '';
            for (let i = 0; i < parts.length - 1; i++) {  // -1 to skip the filename
                currentPath = currentPath ? `${currentPath}/${parts[i]}` : parts[i];
                this.expandedFolders[currentPath] = true;
            }
            // Re-render tree to show expanded folders
            const treeContainer = document.querySelector('[x-html="renderTree(tree)"]');
            if (treeContainer) {
                treeContainer.innerHTML = this.renderTree(this.tree);
            }
        },

        onTreeScroll() {
            if (this._scrollTimeout) return;
            this._scrollTimeout = setTimeout(() => {
                this._scrollTimeout = null;
                const container = this.$refs.treeContainer;
                if (!container) return;
                const scrollTop = container.scrollTop;
                const startItem = Math.floor(scrollTop / this.ITEM_HEIGHT);
                this.updateFolderScrollStates(this.tree, startItem);
                const treeHtml = container.querySelector('[x-html="renderTree(tree)"]');
                if (treeHtml) {
                    treeHtml.innerHTML = this.renderTree(this.tree);
                }
            }, 50);
        },

        updateFolderScrollStates(node, startItem) {
            if (!node || !node.children) return;
            const isExpanded = this.expandedFolders[node.path] !== false;
            if (isExpanded && node.children.length > 100) {
                this.folderScrollState[node.path] = { start: startItem };
            }
            for (const child of node.children) {
                if (child.type === 'directory') {
                    this.updateFolderScrollStates(child, startItem);
                }
            }
        },

        renderTree(node, depth = 0) {
            if (!node) return '';
            const indent = 'padding-left: ' + (depth * 16) + 'px';
            const isParquet = node.name.endsWith('.parquet');
            const isPt = node.name.endsWith('.pt');
            const isFile = node.type === 'file' || isParquet || isPt;

            if (isFile) {
                const isSelected = this.selectedPath === node.path;
                const selectedClass = isSelected ? 'bg-neutral-700' : '';
                let textClass = '';
                let badge = '';
                let displayName = node.name;

                if (isParquet) {
                    textClass = 'text-emerald-400';
                    badge = '<span class="ml-1 px-1 py-0.5 text-[10px] rounded bg-emerald-900/50 text-emerald-300">parquet</span>';
                    displayName = node.name.replace('.parquet', '');
                } else if (isPt) {
                    textClass = 'text-purple-400';
                    badge = '<span class="ml-1 px-1 py-0.5 text-[10px] rounded bg-purple-900/50 text-purple-300">pt</span>';
                    displayName = node.name.replace('.pt', '');
                }

                const fileIcon = isParquet ? '&#128202;' : (isPt ? '&#129302;' : '&#128196;');
                return `
                    <div class="tree-item py-1 px-2 rounded text-sm flex items-center gap-1 ${selectedClass}" style="${indent}"
                         onclick="window.dataBrowserInstance?.selectFile({name: '${node.name}', path: '${node.path}', size: ${node.size || 0}})">
                        <span class="text-gray-400 text-xs">${fileIcon}</span>
                        <span class="${textClass}">${displayName}</span>
                        ${badge}
                    </div>
                `;
            }

            const totalFiles = node.total_files || node.count || 0;
            const totalSize = node.total_size ? this.formatBytes(node.total_size) : '';
            const sizeDisplay = totalSize ? ` - ${totalSize}` : '';
            const isRootFolder = depth === 0;
            const isExpanded = isRootFolder ? this.expandedFolders[node.path] !== false : this.expandedFolders[node.path] === true;
            const chevron = isExpanded ? '&#9662;' : '&#9656;';

            let html = `
                <div class="tree-item py-1 px-2 rounded text-sm font-medium flex items-center gap-1" style="${indent}"
                     onclick="window.dataBrowserInstance?.toggleFolder('${node.path}')">
                    <span class="text-gray-500 text-xs w-3">${chevron}</span>
                    <span class="text-yellow-500 text-xs">&#128193;</span>
                    <span>${node.name}</span>
                    <span class="text-gray-500 text-xs ml-1">(${totalFiles} files${sizeDisplay})</span>
                </div>
            `;

            if (node.children && isExpanded) {
                const childCount = node.children.length;
                const VIRTUAL_THRESHOLD = 100;

                if (childCount > VIRTUAL_THRESHOLD) {
                    const scrollState = this.folderScrollState[node.path] || { start: 0 };
                    const containerHeight = this.$refs.treeContainer?.clientHeight || 500;
                    const visibleCount = Math.ceil(containerHeight / this.ITEM_HEIGHT) + this.VISIBLE_BUFFER * 2;
                    const start = Math.max(0, scrollState.start - this.VISIBLE_BUFFER);
                    const end = Math.min(childCount, start + visibleCount);

                    if (start > 0) {
                        html += `<div style="height: ${start * this.ITEM_HEIGHT}px"></div>`;
                    }
                    for (let i = start; i < end; i++) {
                        html += this.renderTree(node.children[i], depth + 1);
                    }
                    if (end < childCount) {
                        html += `<div style="height: ${(childCount - end) * this.ITEM_HEIGHT}px"></div>`;
                    }
                    html += `<div class="text-xs text-gray-500 pl-8 py-1" style="${indent}">Showing ${start + 1}-${end} of ${childCount} items</div>`;
                } else {
                    for (const child of node.children) {
                        html += this.renderTree(child, depth + 1);
                    }
                }
            }
            return html;
        },

        async loadDirectory(path) {
            this.currentPath = path;
            const res = await fetch('/api/data');
            this.tree = await res.json();
        },

        async selectFile(file) {
            this.selectedFile = file;
            this.selectedPath = file.path;
            this.previewOffset = 0;
            this.statsData = null;
            this.fileInfo = null;
            this.sortColumn = null;
            this.sortDirection = 'asc';
            this.allData = [];
            this.loadingMore = false;
            this.miniChartData = null;
            this.miniChartError = null;

            const isChartable = this.isChartableFile(file);

            if (file.name.endsWith('.parquet')) {
                if (isChartable) {
                    this.previewTab = 'chart';
                    this.loadMiniChart();
                    this.loadPreview();
                } else {
                    this.previewTab = 'data';
                    await this.loadPreview();
                }
            } else if (file.name.endsWith('.pt')) {
                this.previewTab = 'data';
                await this.loadFileInfo();
            } else {
                this.previewTab = 'data';
            }

            const treeContainer = document.querySelector('[x-html="renderTree(tree)"]');
            if (treeContainer) {
                treeContainer.innerHTML = this.renderTree(this.tree);
            }

            // Update URL with selected file
            this.updateUrl();
        },

        closePreview() {
            this.selectedFile = null;
            this.selectedPath = '';
            this.previewData = null;
            this.fileInfo = null;
            this.allData = [];
            const treeContainer = document.querySelector('[x-html="renderTree(tree)"]');
            if (treeContainer) {
                treeContainer.innerHTML = this.renderTree(this.tree);
            }
            // Update URL to remove file param
            this.updateUrl();
        },

        buildPreviewUrl(offset) {
            let url = `/api/parquet/preview?path=${encodeURIComponent(this.selectedFile.path)}&offset=${offset}&limit=${this.previewLimit}`;
            if (this.sortColumn) {
                url += `&sort_by=${encodeURIComponent(this.sortColumn)}&sort_dir=${this.sortDirection}`;
            }
            return url;
        },

        async loadPreview() {
            const res = await fetch(this.buildPreviewUrl(this.previewOffset));
            this.previewData = await res.json();
            this.allData = this.previewData.data || [];
        },

        async loadMoreData() {
            if (this.loadingMore) return;
            if (!this.previewData || this.allData.length >= this.previewData.total_rows) return;
            this.loadingMore = true;
            this.previewOffset = this.allData.length;
            const res = await fetch(this.buildPreviewUrl(this.previewOffset));
            const newData = await res.json();
            if (newData.data && newData.data.length > 0) {
                this.allData = [...this.allData, ...newData.data];
            }
            this.loadingMore = false;
        },

        onTableScroll(event) {
            const el = event.target;
            if (el.scrollHeight - el.scrollTop - el.clientHeight < 200) {
                this.loadMoreData();
            }
        },

        async loadStats() {
            if (this.statsData) return;
            this.selectedColumn = null;
            this.histogramData = null;
            const res = await fetch(`/api/parquet/stats?path=${encodeURIComponent(this.selectedFile.path)}`);
            this.statsData = await res.json();
        },

        async selectColumn(colName) {
            this.selectedColumn = colName;
            this.histogramLoading = true;
            this.histogramData = null;
            try {
                const res = await fetch(`/api/parquet/histogram?path=${encodeURIComponent(this.selectedFile.path)}&column=${encodeURIComponent(colName)}&bins=50`);
                this.histogramData = await res.json();
                this.$nextTick(() => this.drawHistogram());
            } catch (e) {
                console.error('Failed to load histogram:', e);
            } finally {
                this.histogramLoading = false;
            }
        },

        drawHistogram() {
            if (!this.histogramData || !this.$refs.histogramCanvas) return;
            const canvas = this.$refs.histogramCanvas;
            const ctx = canvas.getContext('2d');
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;

            const data = this.histogramData;
            const counts = data.counts;
            const edges = data.edges;
            const maxCount = Math.max(...counts);

            const padding = { top: 20, right: 20, bottom: 50, left: 60 };
            const chartWidth = canvas.width - padding.left - padding.right;
            const chartHeight = canvas.height - padding.top - padding.bottom;

            ctx.fillStyle = '#171717';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = '#404040';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top);
            ctx.lineTo(padding.left, canvas.height - padding.bottom);
            ctx.lineTo(canvas.width - padding.right, canvas.height - padding.bottom);
            ctx.stroke();

            const barWidth = chartWidth / counts.length;
            ctx.fillStyle = '#22c55e';
            for (let i = 0; i < counts.length; i++) {
                const barHeight = (counts[i] / maxCount) * chartHeight;
                const x = padding.left + i * barWidth;
                const y = canvas.height - padding.bottom - barHeight;
                ctx.fillRect(x, y, barWidth - 1, barHeight);
            }

            ctx.fillStyle = '#9ca3af';
            ctx.font = '10px monospace';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';

            const yTicks = 5;
            for (let i = 0; i <= yTicks; i++) {
                const value = Math.round((maxCount / yTicks) * i);
                const y = canvas.height - padding.bottom - (i / yTicks) * chartHeight;
                ctx.fillText(value.toLocaleString(), padding.left - 5, y);
                ctx.strokeStyle = '#2a2a2a';
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(canvas.width - padding.right, y);
                ctx.stroke();
            }

            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            const xTicks = Math.min(5, edges.length);
            for (let i = 0; i <= xTicks; i++) {
                const edgeIdx = Math.floor((i / xTicks) * (edges.length - 1));
                const value = edges[edgeIdx];
                const x = padding.left + (edgeIdx / (edges.length - 1)) * chartWidth;
                let label;
                if (data.is_datetime) {
                    const date = new Date(value);
                    label = date.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
                } else if (typeof value === 'number') {
                    label = value >= 1000 ? (value / 1000).toFixed(1) + 'k' : value.toFixed(2);
                } else {
                    label = String(value).substring(0, 10);
                }
                ctx.fillText(label, x, canvas.height - padding.bottom + 5);
            }
        },

        async loadFileInfo() {
            const res = await fetch(`/api/file/info?path=${encodeURIComponent(this.selectedFile.path)}`);
            this.fileInfo = await res.json();
            this.selectedPytorchKey = null;
            this.pytorchKeyData = null;
        },

        async inspectPytorchKey(keyName) {
            this.selectedPytorchKey = keyName;
            this.pytorchKeyLoading = true;
            this.pytorchKeyData = null;
            try {
                const res = await fetch(`/api/pytorch/key?path=${encodeURIComponent(this.selectedFile.path)}&key=${encodeURIComponent(keyName)}`);
                this.pytorchKeyData = await res.json();
            } catch (e) {
                console.error('Failed to inspect key:', e);
                this.pytorchKeyData = { error: e.message };
            } finally {
                this.pytorchKeyLoading = false;
            }
        },

        isChartableFile(file) {
            if (!file || !file.path) return false;
            if (!file.name.endsWith('.parquet')) return false;
            const chartablePaths = [
                'cache/raw/', '/stocks/', '/options/', '/greeks/', '/oi/',
                '/gex_flow/', '/options-flow-1m/', '/greeks-1m/', '/oi-day/',
                '/training-1m-raw/', '/training-1m-normalized/',
                'stocks-1m/', 'options-1m/', 'greeks-1m/', 'oi-day/',
                'training-1m-raw/', 'training-1m-normalized/', 'options-flow-1m/',
            ];
            return chartablePaths.some(p => file.path.includes(p));
        },

        isRawCacheFile(file) {
            return this.isChartableFile(file);
        },

        async loadMiniChart() {
            if (!this.selectedFile) return;
            Object.values(this.miniCharts).forEach(chart => {
                if (chart && chart.remove) chart.remove();
            });
            this.miniCharts = {};
            this.miniChartLoading = true;
            this.miniChartError = null;
            this.miniChartData = null;

            try {
                const res = await fetch(`/api/chart/data?path=${encodeURIComponent(this.selectedFile.path)}`);
                const data = await res.json();
                if (data.error) {
                    this.miniChartError = data.error;
                    return;
                }
                this.miniChartData = data;
                this.$nextTick(() => {
                    setTimeout(() => this.renderMiniChart(), 100);
                });
            } catch (e) {
                this.miniChartError = e.message;
            } finally {
                this.miniChartLoading = false;
            }
        },

        renderMiniChart() {
            if (!this.miniChartData || !window.LightweightCharts) return;

            const chartOptions = {
                layout: {
                    background: { type: 'solid', color: '#0a0a0a' },
                    textColor: '#9ca3af',
                },
                grid: {
                    vertLines: { color: '#1f1f1f' },
                    horzLines: { color: '#1f1f1f' },
                },
                crosshair: { mode: 1 },
                timeScale: {
                    borderColor: '#333',
                    timeVisible: true,
                    secondsVisible: false,
                    fixLeftEdge: true,
                    fixRightEdge: true,
                },
                rightPriceScale: { borderColor: '#333' },
            };

            const chartType = this.miniChartData.chart_type || 'ohlcv';
            const tooltip = document.getElementById('mini-chart-tooltip');
            const self = this;

            const mainContainer = document.getElementById('mini-chart-main');
            if (mainContainer) {
                mainContainer.innerHTML = '';

                if (chartType === 'oi') {
                    this.renderInteractiveOIChart(mainContainer, chartOptions, tooltip);
                } else if (chartType === 'training_raw' && this.miniChartData.ohlcv?.length > 0) {
                    // Simplified mini chart for training_raw - candles + gamma levels only
                    const chart = LightweightCharts.createChart(mainContainer, {
                        ...chartOptions,
                        height: 280,
                        width: mainContainer.clientWidth,
                        leftPriceScale: { visible: false },
                        rightPriceScale: { visible: false },
                        timeScale: { ...chartOptions.timeScale, visible: false },
                        grid: { vertLines: { visible: false }, horzLines: { visible: false } },
                    });
                    this.miniCharts.main = chart;

                    const candlestickSeries = chart.addCandlestickSeries({
                        upColor: '#26a69a', downColor: '#ef5350', borderVisible: false,
                        wickUpColor: '#26a69a', wickDownColor: '#ef5350',
                        lastValueVisible: false, priceLineVisible: false,
                    });
                    candlestickSeries.setData(this.miniChartData.ohlcv);

                    // Add volume overlays: 0V, +VW, -VW only
                    const data = this.miniChartData;

                    // 0V - Most Active Strike (blue solid)
                    if (data.most_active_strike?.length > 0) {
                        const masSeries = chart.addLineSeries({ color: '#3b82f6', lineWidth: 2, lastValueVisible: false, priceLineVisible: false });
                        masSeries.setData(data.most_active_strike);
                    }

                    // +VW - Call Weighted Strike (green dashed)
                    if (data.call_weighted_strike?.length > 0) {
                        const cwsSeries = chart.addLineSeries({ color: '#22c55e', lineWidth: 2, lineStyle: 2, lastValueVisible: false, priceLineVisible: false });
                        cwsSeries.setData(data.call_weighted_strike);
                    }

                    // -VW - Put Weighted Strike (red dashed)
                    if (data.put_weighted_strike?.length > 0) {
                        const pwsSeries = chart.addLineSeries({ color: '#ef4444', lineWidth: 2, lineStyle: 2, lastValueVisible: false, priceLineVisible: false });
                        pwsSeries.setData(data.put_weighted_strike);
                    }

                    chart.subscribeCrosshairMove(param => {
                        self.updateMiniTooltip(param, tooltip, 'ohlcv', candlestickSeries);
                    });
                    chart.timeScale().fitContent();
                } else if (this.miniChartData.ohlcv?.length > 0) {
                    const chart = LightweightCharts.createChart(mainContainer, {
                        ...chartOptions, height: 200, width: mainContainer.clientWidth,
                    });
                    this.miniCharts.main = chart;

                    const candlestickSeries = chart.addCandlestickSeries({
                        upColor: '#26a69a', downColor: '#ef5350', borderVisible: false,
                        wickUpColor: '#26a69a', wickDownColor: '#ef5350',
                    });
                    candlestickSeries.setData(this.miniChartData.ohlcv);

                    chart.subscribeCrosshairMove(param => {
                        self.updateMiniTooltip(param, tooltip, 'ohlcv', candlestickSeries);
                    });

                    if (this.miniChartData.vwap?.length > 0) {
                        const vwapSeries = chart.addLineSeries({ color: '#eab308', lineWidth: 1 });
                        vwapSeries.setData(this.miniChartData.vwap);
                    }
                    chart.timeScale().fitContent();
                } else if (this.miniChartData.price?.length > 0) {
                    const chart = LightweightCharts.createChart(mainContainer, {
                        ...chartOptions, height: 200, width: mainContainer.clientWidth,
                    });
                    this.miniCharts.main = chart;

                    const priceSeries = chart.addLineSeries({ color: '#3b82f6', lineWidth: 2, title: 'Price' });
                    priceSeries.setData(this.miniChartData.price);

                    chart.subscribeCrosshairMove(param => {
                        self.updateMiniTooltip(param, tooltip, 'gex', priceSeries);
                    });
                    chart.timeScale().fitContent();
                } else if (this.miniChartData.call_volume?.length > 0) {
                    const chart = LightweightCharts.createChart(mainContainer, {
                        ...chartOptions, height: 200, width: mainContainer.clientWidth,
                        leftPriceScale: { visible: true, borderColor: '#333', scaleMargins: { top: 0.1, bottom: 0.1 } },
                        rightPriceScale: { visible: false },
                        localization: { priceFormatter: (price) => this.formatLargeNumber(Math.abs(price)) },
                    });
                    this.miniCharts.main = chart;

                    const callSeries = chart.addHistogramSeries({ color: '#26a69a', priceScaleId: 'left', priceFormat: { type: 'volume' }, title: 'Call Vol' });
                    callSeries.setData(this.miniChartData.call_volume);
                    const putSeries = chart.addHistogramSeries({ color: '#ef5350', priceScaleId: 'left', priceFormat: { type: 'volume' }, title: 'Put Vol' });
                    putSeries.setData(this.miniChartData.put_volume);

                    chart.subscribeCrosshairMove(param => {
                        self.updateMiniTooltip(param, tooltip, 'options', null);
                    });
                    chart.timeScale().fitContent();
                } else if (this.miniChartData.call_delta?.length > 0) {
                    const chart = LightweightCharts.createChart(mainContainer, {
                        ...chartOptions, height: 200, width: mainContainer.clientWidth,
                        leftPriceScale: { visible: true, borderColor: '#333', scaleMargins: { top: 0.1, bottom: 0.1 } },
                        rightPriceScale: { visible: false },
                    });
                    this.miniCharts.main = chart;

                    const callSeries = chart.addHistogramSeries({ color: '#26a69a', priceScaleId: 'left', title: 'Call Delta' });
                    callSeries.setData(this.miniChartData.call_delta);
                    const putSeries = chart.addHistogramSeries({ color: '#ef5350', priceScaleId: 'left', title: 'Put Delta' });
                    putSeries.setData(this.miniChartData.put_delta);

                    chart.subscribeCrosshairMove(param => {
                        self.updateMiniTooltip(param, tooltip, 'greeks', null);
                    });
                    chart.timeScale().fitContent();
                }
            }

            const secondaryContainer = document.getElementById('mini-chart-secondary');
            if (secondaryContainer) {
                secondaryContainer.innerHTML = '';
                const secHeight = chartType === 'training_raw' ? 60 : 100;

                if (this.miniChartData.volume?.length > 0) {
                    const hideLabels = chartType === 'training_raw';
                    const volChart = LightweightCharts.createChart(secondaryContainer, {
                        ...chartOptions,
                        height: secHeight,
                        width: secondaryContainer.clientWidth,
                        leftPriceScale: { visible: !hideLabels, borderColor: '#333', minimumWidth: 50 },
                        rightPriceScale: { visible: false },
                        timeScale: { ...chartOptions.timeScale, visible: !hideLabels },
                        grid: hideLabels ? { vertLines: { visible: false }, horzLines: { visible: false } } : chartOptions.grid,
                    });
                    this.miniCharts.volume = volChart;
                    const volSeries = volChart.addHistogramSeries({ priceScaleId: hideLabels ? '' : 'left', lastValueVisible: false, priceLineVisible: false });
                    volSeries.setData(this.miniChartData.volume);
                    volChart.timeScale().fitContent();
                } else if (this.miniChartData.net_gamma_flow?.length > 0) {
                    const gexChart = LightweightCharts.createChart(secondaryContainer, {
                        ...chartOptions, height: secHeight, width: secondaryContainer.clientWidth,
                    });
                    this.miniCharts.gex = gexChart;
                    const gexSeries = gexChart.addHistogramSeries({ priceScaleId: '' });
                    gexSeries.setData(this.miniChartData.net_gamma_flow.map(d => ({
                        ...d, color: d.value >= 0 ? '#22c55e' : '#ef4444'
                    })));
                    gexChart.timeScale().fitContent();
                } else if (this.miniChartData.pc_ratio?.length > 0) {
                    const pcChart = LightweightCharts.createChart(secondaryContainer, {
                        ...chartOptions, height: secHeight, width: secondaryContainer.clientWidth,
                    });
                    this.miniCharts.pcRatio = pcChart;
                    const pcSeries = pcChart.addLineSeries({ color: '#f59e0b', lineWidth: 1 });
                    pcSeries.setData(this.miniChartData.pc_ratio);
                    pcChart.timeScale().fitContent();
                } else if (this.miniChartData.avg_iv?.length > 0) {
                    const ivChart = LightweightCharts.createChart(secondaryContainer, {
                        ...chartOptions, height: secHeight, width: secondaryContainer.clientWidth,
                    });
                    this.miniCharts.iv = ivChart;
                    const ivSeries = ivChart.addLineSeries({ color: '#a855f7', lineWidth: 2, title: 'Avg IV %' });
                    ivSeries.setData(this.miniChartData.avg_iv);
                    ivChart.timeScale().fitContent();
                }
            }

            // Tertiary container - Velocity chart for training_raw
            const tertiaryContainer = document.getElementById('mini-chart-tertiary');
            if (tertiaryContainer && this.miniChartData.market_velocity?.length > 0) {
                tertiaryContainer.innerHTML = '';
                const velChart = LightweightCharts.createChart(tertiaryContainer, {
                    ...chartOptions,
                    height: 60,
                    width: tertiaryContainer.clientWidth,
                    leftPriceScale: { visible: false },
                    rightPriceScale: { visible: false },
                    timeScale: { ...chartOptions.timeScale, visible: false },
                    grid: { vertLines: { visible: false }, horzLines: { visible: false } },
                });
                this.miniCharts.velocity = velChart;
                const velSeries = velChart.addHistogramSeries({ lastValueVisible: false, priceLineVisible: false });
                velSeries.setData(this.miniChartData.market_velocity.map(d => ({
                    ...d, color: d.value >= 0 ? '#22c55e' : '#ef4444'
                })));
                velChart.timeScale().fitContent();
            }

            // Sync time scales for mini charts - bidirectional
            const miniChartsArray = Object.values(this.miniCharts).filter(c => c);
            if (miniChartsArray.length > 1) {
                // Initial sync from main chart
                const mainMiniChart = this.miniCharts.main;
                if (mainMiniChart) {
                    const mainRange = mainMiniChart.timeScale().getVisibleRange();
                    if (mainRange) {
                        miniChartsArray.forEach(chart => {
                            if (chart !== mainMiniChart) {
                                chart.timeScale().setVisibleRange(mainRange);
                            }
                        });
                    }
                }

                // Subscribe to ongoing changes for bidirectional sync
                let isSyncing = false;
                miniChartsArray.forEach(chart => {
                    chart.timeScale().subscribeVisibleTimeRangeChange(range => {
                        if (isSyncing || !range) return;
                        isSyncing = true;
                        miniChartsArray.forEach(otherChart => {
                            if (otherChart !== chart) {
                                otherChart.timeScale().setVisibleRange(range);
                            }
                        });
                        isSyncing = false;
                    });
                });
            }
        },

        renderInteractiveOIChart(container, chartOptions, tooltip) {
            const data = this.miniChartData;
            if (!data.strikes || data.strikes.length === 0) return;

            const self = this;
            const baseTime = 946684800;
            const strikeToTime = (strike) => baseTime + (strike * 86400);
            const timeToStrike = (time) => (time - baseTime) / 86400;

            const chart = LightweightCharts.createChart(container, {
                ...chartOptions, height: 220, width: container.clientWidth,
                timeScale: {
                    ...chartOptions.timeScale,
                    tickMarkFormatter: (time) => timeToStrike(time).toFixed(0),
                    rightOffset: 2, barSpacing: 12,
                },
                localization: {
                    timeFormatter: (time) => `Strike: $${timeToStrike(time).toFixed(0)}`,
                    priceFormatter: (price) => this.formatLargeNumber(Math.abs(price)),
                },
            });
            this.miniCharts.main = chart;

            const callSeries = chart.addHistogramSeries({ color: '#26a69a', priceFormat: { type: 'volume' }, priceScaleId: 'right' });
            const putSeries = chart.addHistogramSeries({ color: '#ef5350', priceFormat: { type: 'volume' }, priceScaleId: 'right' });

            const callData = data.call_oi.map(d => ({ time: strikeToTime(d.strike), value: d.value, color: '#26a69a' }));
            const putData = data.put_oi.map(d => ({ time: strikeToTime(d.strike), value: -d.value, color: '#ef5350' }));

            callSeries.setData(callData);
            putSeries.setData(putData);

            chart.subscribeCrosshairMove(param => {
                if (!param.time || !tooltip) {
                    if (tooltip) tooltip.classList.add('hidden');
                    return;
                }
                const strike = timeToStrike(param.time);
                const callPoint = data.call_oi.find(d => Math.abs(d.strike - strike) < 0.5);
                const putPoint = data.put_oi.find(d => Math.abs(d.strike - strike) < 0.5);
                const callOI = callPoint ? callPoint.value : 0;
                const putOI = putPoint ? putPoint.value : 0;
                const netOI = callOI - putOI;
                const pcRatio = callOI > 0 ? (putOI / callOI).toFixed(2) : 'N/A';

                tooltip.innerHTML = `
                    <div class="font-semibold text-white mb-1">Strike: $${strike.toFixed(0)}</div>
                    <div class="flex gap-3">
                        <span class="text-emerald-400">Call: ${self.formatLargeNumberStyled(callOI)}</span>
                        <span class="text-red-400">Put: ${self.formatLargeNumberStyled(putOI)}</span>
                    </div>
                    <div class="text-neutral-400 text-xs mt-1">
                        Net: ${netOI >= 0 ? '+' : ''}${self.formatLargeNumberStyled(netOI)} | P/C: ${pcRatio}
                    </div>
                `;
                tooltip.classList.remove('hidden');
            });

            chart.timeScale().fitContent();
            container.style.position = 'relative';
        },

        async openChart() {
            if (!this.selectedFile) return;
            this.chartModalOpen = true;
            this.chartLoading = true;
            this.chartError = null;
            this.chartData = null;

            // Update URL to include extended parameter
            if (!this._initializing) {
                this.updateUrl();
            }

            try {
                const res = await fetch(`/api/chart/data?path=${encodeURIComponent(this.selectedFile.path)}`);
                const data = await res.json();
                if (data.error) {
                    this.chartError = data.error;
                    return;
                }
                this.chartData = data;
                this.$nextTick(() => {
                    setTimeout(() => this.renderCharts(), 100);
                });
            } catch (e) {
                this.chartError = e.message;
            } finally {
                this.chartLoading = false;
            }
        },

        closeChart() {
            Object.values(this.charts).forEach(chart => {
                if (chart && chart.remove) chart.remove();
            });
            this.charts = {};
            this.chartSeries = {};
            this.chartModalOpen = false;
            this.chartData = null;
            this.chartZoomed = false;

            // Update URL to remove extended parameter
            this.updateUrl();
        },

        toggleChartZoom() {
            this.chartZoomed = !this.chartZoomed;
            TrainingChartView.chartZoomed = this.chartZoomed;
            // Trigger resize and x-axis update after Alpine updates the DOM
            this.$nextTick(() => {
                TrainingChartView.handleResize();
                TrainingChartView.updateXAxisVisibility();
            });
        },

        // Handle window resize - delegate to TrainingChartView
        handleChartResize() {
            if (!this.chartModalOpen || !this.chartData) return;

            // Debounce resize events
            if (this._resizeTimeout) clearTimeout(this._resizeTimeout);
            this._resizeTimeout = setTimeout(() => {
                TrainingChartView.handleResize();
            }, 100);
        },

        toggleOverlay(overlayName) {
            // Sync local state and delegate to TrainingChartView
            this.overlayVisible[overlayName] = !this.overlayVisible[overlayName];
            TrainingChartView.overlayVisible[overlayName] = this.overlayVisible[overlayName];
            TrainingChartView.toggleOverlay(overlayName);
            // Toggle back since TrainingChartView.toggleOverlay toggles internally
            TrainingChartView.overlayVisible[overlayName] = this.overlayVisible[overlayName];
            const series = TrainingChartView.chartSeries[overlayName];
            if (series) {
                series.applyOptions({ visible: this.overlayVisible[overlayName] });
            }
        },

        // Legend groups for batch toggling (same as TrainingChartView)
        legendGroups: {
            price: ['vwap', 'rollingVwap', 'vwapUpper1', 'vwapLower1', 'vwapUpper2', 'vwapLower2', 'pointOfControl'],
            gamma: ['zeroGex', 'positiveGws', 'negativeGws', 'gammaCallWall', 'gammaPutWall'],
            delta: ['zeroDex', 'deltaSupport', 'deltaResistance', 'dexCallWall', 'dexPutWall'],
            volume: ['mostActiveStrike', 'callWeightedStrike', 'putWeightedStrike', 'maxCallStrike', 'maxPutStrike'],
            prior: ['premarketHigh', 'premarketLow', 'threeDayHigh', 'threeDayLow'],
        },

        isGroupVisible(groupName) {
            const items = this.legendGroups[groupName] || [];
            return items.some(name => this.overlayVisible[name]);
        },

        toggleGroup(groupName) {
            const items = this.legendGroups[groupName] || [];
            const anyVisible = items.some(name => this.overlayVisible[name]);
            const newState = !anyVisible;
            items.forEach(name => {
                this.overlayVisible[name] = newState;
                TrainingChartView.overlayVisible[name] = newState;
                const series = TrainingChartView.chartSeries[name];
                if (series) {
                    series.applyOptions({ visible: newState });
                }
            });
        },

        renderCharts() {
            if (!this.chartData || !window.LightweightCharts) return;

            // Sync overlay visibility state to TrainingChartView before rendering
            Object.assign(TrainingChartView.overlayVisible, this.overlayVisible);

            // Delegate to TrainingChartView
            TrainingChartView.render(this.chartData);

            // Keep references for compatibility
            this.charts = TrainingChartView.charts;
            this.chartSeries = TrainingChartView.chartSeries;
        },

        // NOTE: renderCharts() now delegates to TrainingChartView.render()
        // The 1000+ lines of legacy chart rendering code has been removed
        // All chart creation, crosshair sync, and tooltip logic is now in training-chart-view.js

        updateMiniTooltip(param, tooltip, chartType, series) {
            if (!param.time || !tooltip) {
                if (tooltip) tooltip.classList.add('hidden');
                return;
            }
            tooltip.classList.remove('hidden');
            const time = new Date(param.time * 1000).toLocaleTimeString();

            if (chartType === 'ohlcv' && series) {
                const data = param.seriesData.get(series);
                if (data) {
                    tooltip.innerHTML = `
                        <div class="font-semibold text-gray-200">${time}</div>
                        <div class="grid grid-cols-2 gap-x-3 gap-y-0.5 mt-1">
                            <span class="text-gray-400">O:</span><span class="text-gray-200">${data.open?.toFixed(2)}</span>
                            <span class="text-gray-400">H:</span><span class="text-gray-200">${data.high?.toFixed(2)}</span>
                            <span class="text-gray-400">L:</span><span class="text-gray-200">${data.low?.toFixed(2)}</span>
                            <span class="text-gray-400">C:</span><span class="text-gray-200">${data.close?.toFixed(2)}</span>
                        </div>
                    `;
                }
            } else if (chartType === 'options') {
                const callData = this.miniChartData?.call_volume?.find(d => d.time === param.time);
                const putData = this.miniChartData?.put_volume?.find(d => d.time === param.time);
                const callVol = callData?.value || 0;
                const putVol = Math.abs(putData?.value || 0);
                const ratio = callVol > 0 ? (putVol / callVol).toFixed(2) : 'N/A';
                tooltip.innerHTML = `
                    <div class="font-semibold text-gray-200">${time}</div>
                    <div class="grid grid-cols-2 gap-x-3 gap-y-0.5 mt-1">
                        <span class="text-green-400">Calls:</span><span class="text-gray-200">${this.formatLargeNumberStyled(callVol)}</span>
                        <span class="text-red-400">Puts:</span><span class="text-gray-200">${this.formatLargeNumberStyled(putVol)}</span>
                        <span class="text-gray-400">P/C:</span><span class="text-yellow-400">${ratio}</span>
                        <span class="text-gray-400">Net:</span><span class="${callVol > putVol ? 'text-green-400' : 'text-red-400'}">${this.formatLargeNumberStyled(callVol - putVol)}</span>
                    </div>
                `;
            } else if (chartType === 'gex') {
                const priceData = this.miniChartData?.price?.find(d => d.time === param.time);
                const gexData = this.miniChartData?.net_gamma_flow?.find(d => d.time === param.time);
                tooltip.innerHTML = `
                    <div class="font-semibold text-gray-200">${time}</div>
                    <div class="grid grid-cols-2 gap-x-3 gap-y-0.5 mt-1">
                        <span class="text-gray-400">Price:</span><span class="text-blue-400">${priceData?.value?.toFixed(2) || 'N/A'}</span>
                        <span class="text-gray-400">GEX:</span><span class="${(gexData?.value || 0) >= 0 ? 'text-green-400' : 'text-red-400'}">${gexData?.value?.toFixed(2) || 'N/A'}</span>
                    </div>
                `;
            } else if (chartType === 'greeks') {
                const callData = this.miniChartData?.call_delta?.find(d => d.time === param.time);
                const putData = this.miniChartData?.put_delta?.find(d => d.time === param.time);
                const ivData = this.miniChartData?.avg_iv?.find(d => d.time === param.time);
                const callDelta = callData?.value || 0;
                const putDelta = putData?.value || 0;
                const netDelta = callDelta + putDelta;
                const iv = ivData?.value || 0;
                tooltip.innerHTML = `
                    <div class="font-semibold text-gray-200">${time}</div>
                    <div class="grid grid-cols-2 gap-x-3 gap-y-0.5 mt-1">
                        <span class="text-green-400">Call :</span><span class="text-gray-200">${callDelta.toFixed(2)}</span>
                        <span class="text-red-400">Put :</span><span class="text-gray-200">${putDelta.toFixed(2)}</span>
                        <span class="text-gray-400">Net :</span><span class="${netDelta >= 0 ? 'text-green-400' : 'text-red-400'}">${netDelta.toFixed(2)}</span>
                        <span class="text-gray-400">Avg IV:</span><span class="text-purple-400">${iv.toFixed(1)}%</span>
                    </div>
                `;
            }
        },

        formatLargeNumber(num) {
            return ChartUtils.formatLargeNumber(num);
        },

        // Get brightness/opacity based on magnitude (for tooltip styling)
        // Returns opacity value: 0.4 for small, 0.7 for medium, 1.0 for large
        getMagnitudeBrightness(num) {
            const abs = Math.abs(num);
            if (abs >= 1e9) return 1.0;      // Billions: brightest
            if (abs >= 1e6) return 0.7;      // Millions: medium
            return 0.4;                       // Thousands or less: dim
        },

        // Format large number with brightness styling
        formatLargeNumberStyled(num, baseColor = 'white') {
            const formatted = this.formatLargeNumber(num);
            const brightness = this.getMagnitudeBrightness(num);
            return `<span style="opacity: ${brightness}">${formatted}</span>`;
        },

        formatBytes(bytes) {
            if (!bytes) return '-';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        },

        formatValue(val) {
            if (val === null || val === undefined) return 'null';
            if (typeof val === 'number') {
                if (Number.isInteger(val)) return val.toLocaleString();
                return val.toFixed(4);
            }
            if (typeof val === 'string' && val.length > 40) return val.substring(0, 40) + '...';
            return val;
        },

        formatStatValue(val) {
            if (val === null || val === undefined) return '-';
            if (typeof val === 'number') return val.toFixed(4);
            return val;
        },

        // Get chart title from file path: "SPY 2026-01-06" format
        // Path format: data/<dataset>/<underlying>/<year-month>/<day>.parquet
        getChartTitle() {
            if (!this.selectedFile?.path) return 'Chart';
            const parts = this.selectedFile.path.split('/');
            if (parts.length < 4) return this.selectedFile.name || 'Chart';

            // Extract underlying (e.g., "SPY") and date components
            const filename = parts[parts.length - 1];  // "06.parquet"
            const yearMonth = parts[parts.length - 2]; // "2026-01"
            const underlying = parts[parts.length - 3]; // "SPY"

            // Get day from filename (remove .parquet extension)
            const day = filename.replace('.parquet', '').padStart(2, '0');

            // Build full date string
            const fullDate = `${yearMonth}-${day}`;

            return `${underlying} ${fullDate}`;
        }
    }
}
</script>
{% endblock %}
